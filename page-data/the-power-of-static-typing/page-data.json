{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/the-power-of-static-typing/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Brainstormer"}},"markdownRemark":{"id":"44ed1db5-5065-5962-a319-de96e1576619","excerpt":"If you studied computer science in university like me or are still studying you might have heard the terms static typing or dynamic typing somewhere in your…","html":"<p>If you studied computer science in university like me or are still studying you might have heard the terms static typing or dynamic typing somewhere in your classes to distinguish programming languages.</p>\n<h3 id=\"what-is-static-typing-and-dynamic-typing\" style=\"position:relative;\"><a href=\"#what-is-static-typing-and-dynamic-typing\" aria-label=\"what is static typing and dynamic typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is static typing and dynamic typing?</h3>\n<p>A programming language is statically typed if the types of all variables are known just by looking at the code. In these languages, you label the variables with their types so the code can be verified before it runs. This procedure is done during the build phase and is called a <strong>typecheck</strong>.</p>\n<p>Java, C++, C#, and Go are very famous static typed languages.</p>\n<p>A programming language is dynamically typed if it doesn’t have a typecheck step, and the types of all variables are only known at runtime. These kinds of languages have the advantage that writing complex code is much faster compared to static typed languages. In order to do this, they have some rules in order to make conversions between different types automatic.</p>\n<p>These rules are called <strong>type coercion</strong> rules.</p>\n<p>Javascript is a very famous example of being a dynamic typed language with this property, along with Python or even Ruby.</p>\n<p>Let’s go for some simple examples.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//Example 1</span>\n<span class=\"token keyword\">let</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n\n<span class=\"token comment\">/*\n    Implicit conversion between string type to boolean type.\n*/</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String is empty!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>From this example we can see that dynamic typing helps writing simpler code, like checking if a string is empty. The same if condition could be used to check if the variable is null or undefined.</p>\n<p>This is great! Let’s go to another example.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//Example 2</span>\n<span class=\"token keyword\">let</span> num <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n<span class=\"token keyword\">let</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"4\"</span>\n<span class=\"token comment\">/* \n    Prints 34 because it will implicitly convert \n    num to a string and concatenate both strings with + operator \n*/</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">+</span> str<span class=\"token punctuation\">)</span>\n</code></pre></div>\n<p>This is an interesting one. The + operator in Javascript works for both numbers and strings even though they behave differently depending on the types.</p>\n<p>This type coercion behavior that dynamic languages have can be the cause of multiple bugs in our code. So to prevent this, we need to always keep good track of the types of the different variables that we are using, as well as the type coercion rules.</p>\n<p>Another way to not deal with these bugs is to…</p>\n<p><strong>Use a static typed language!</strong></p>\n<p>Static typed languages prevent us from performing these operations with different data types! This is because the typecheck step will throw an error before even running your code.</p>\n<p>Here are some examples of what I mean, this time in Go!</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">\n<span class=\"token comment\">//Example 3</span>\n\t<span class=\"token keyword\">var</span> str <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token comment\">/*\n        Will error\n    */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>str <span class=\"token punctuation\">{</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String is empty\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>When we try and build code that contains this example, the typecheck will throw the following error:</p>\n<p><code class=\"language-text\">invalid operation: !str (operator ! not defined on string)</code></p>\n<p>The message is clear clear, it means we can’t use a boolean ! operator on a string.</p>\n<p>So how would we check if the string is empty?</p>\n<p>We would have to compare it directly with an empty string with a != operator. The same would apply for null check.</p>\n<p>As so we can conclude that in some operations, we can take advantage of type coercion to write some operations in a simpler way! But we need to keep track of the different data types to prevent errors.While with static typed languages, even though we might have to write more extensive code, the typecheck will be there to protect from some bugs.</p>\n<h3 id=\"why-i-prefer-static-typed-languages\" style=\"position:relative;\"><a href=\"#why-i-prefer-static-typed-languages\" aria-label=\"why i prefer static typed languages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why I prefer static typed languages</h3>\n<p>There is another situation where static typed languages also help you develop code besides preventing type coercion bugs I would like to talk about.</p>\n<p>I worked exclusively with Javascript and NodeJS for over 2 years of my career and when developing a new functionality like integrating a new API or a library, it would take a bit of time getting to know what are the different parameters and data types to be used. On some instances it would be a trial and error procedure to test and verify if no data was missing.</p>\n<p>Currently I’ve been working with Typescript and Go where I built a GraphQL API composed of multiple queries and mutations. Some of these mutations require a payload object with multiple required fields of different types. Due to this, when writing the code to perform the mutation, some fields might be missing.</p>\n<p>So, instead of going through the trial and error procedure to test and verify the data, the typecheck always warns if there is a missing field.</p>\n<h3 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h3>\n<p>Even though dynamic languages have been very popular to write complex software with Frameworks like Django or even Ruby on Rails, since Typescript appeared as an alternative to Javascript it seems there’s been a rise in popularity for static typed languages again, even in creating new ones with this characteristic like Kotlin, Go or even Rust.</p>\n<p>I feel they bring huge advantages to developers in terms of productivity and security and with modern syntax they also takes some of the pain from writing complex code.</p>","fields":{"slug":"/the-power-of-static-typing/","readingTime":{"text":"5 min read"}},"frontmatter":{"title":"The power of static typing","date":"March 13, 2022","description":"Go and Typescript are currently my favorite programming languages to work with. What do they have in common? They're both statically typed."}},"previous":{"fields":{"slug":"/the-value-of-a-designer-in-a-new-project/"},"frontmatter":{"title":"The value of a designer in a software project"}},"next":{"fields":{"slug":"/an-introduction-to-graphql-part-1/"},"frontmatter":{"title":"Introduction to GraphQL - Part 1"}}},"pageContext":{"id":"44ed1db5-5065-5962-a319-de96e1576619","previousPostId":"0ed74d6b-1623-572b-be1b-ac8c1b988ad7","nextPostId":"08714305-11be-5d9f-a15b-53db3a55bdd2"}},
    "staticQueryHashes": ["2841359383","3257411868"]}